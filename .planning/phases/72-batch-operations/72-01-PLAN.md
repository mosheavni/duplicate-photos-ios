---
phase: 72-batch-operations
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - DuplicatePhotos/Models/PhotoAsset.swift
  - DuplicatePhotos/Models/DuplicateGroup.swift
  - DuplicatePhotos/ViewModels/ScanViewModel.swift
autonomous: true

must_haves:
  truths:
    - "App can determine which photo in a group is highest quality"
    - "App can identify which photos to delete in a group (all except best)"
    - "ScanViewModel can remove groups after deletion"
  artifacts:
    - path: "DuplicatePhotos/Models/PhotoAsset.swift"
      provides: "Quality score computation"
      contains: "qualityScore"
    - path: "DuplicatePhotos/Models/DuplicateGroup.swift"
      provides: "Best photo selection and deletion helpers"
      contains: "bestPhoto"
    - path: "DuplicatePhotos/ViewModels/ScanViewModel.swift"
      provides: "Group removal after deletion"
      contains: "removeGroup"
  key_links:
    - from: "DuplicateGroup.bestPhoto"
      to: "PhotoAsset.qualityScore"
      via: "max comparison"
      pattern: "photos\\.max.*qualityScore"
---

<objective>
Add quality scoring to PhotoAsset and selection helpers to DuplicateGroup for intelligent auto-selection of photos to keep/delete.

Purpose: Enable the UI to auto-select the "best" photo to keep based on resolution, file size, and recency heuristics. This is the foundation for single-tap "delete duplicates" functionality.

Output: Enhanced models with quality scoring and ScanViewModel with group removal support.
</objective>

<execution_context>
@/Users/Moshe.Avni/.claude/get-shit-done/workflows/execute-plan.md
@/Users/Moshe.Avni/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/72-batch-operations/72-CONTEXT.md
@.planning/phases/72-batch-operations/72-RESEARCH.md
@DuplicatePhotos/Models/PhotoAsset.swift
@DuplicatePhotos/Models/DuplicateGroup.swift
@DuplicatePhotos/ViewModels/ScanViewModel.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add quality score to PhotoAsset</name>
  <files>DuplicatePhotos/Models/PhotoAsset.swift</files>
  <action>
Add a computed `qualityScore` property to PhotoAsset that calculates a quality score based on:
- Resolution: pixelWidth * pixelHeight (50% weight)
- File size: via PHAssetResource (30% weight)
- Recency: creationDate (20% weight, more recent = higher)

Normalize each factor to 0-1 range before weighting:
- Resolution: divide by 100_000_000 (100MP max)
- File size: divide by 50_000_000 (50MB max)
- Recency: use abs(timeIntervalSinceNow) / (365 * 24 * 3600), invert so newer is higher

Add helper method `getFileSize() -> Int64` using PHAssetResource.assetResources(for:).

Import Photos framework if not already imported for PHAssetResource access.

Example implementation from RESEARCH.md:
```swift
var qualityScore: Double {
    let resolution = Double(phAsset.pixelWidth * phAsset.pixelHeight)
    let fileSize = getFileSize()
    let recencyScore = phAsset.creationDate?.timeIntervalSinceNow ?? 0

    let normalizedResolution = min(resolution / 100_000_000.0, 1.0)
    let normalizedSize = min(Double(fileSize) / 50_000_000.0, 1.0)
    let normalizedRecency = 1.0 - min(abs(recencyScore) / (365.0 * 24.0 * 3600.0), 1.0)

    return (normalizedResolution * 0.5) + (normalizedSize * 0.3) + (normalizedRecency * 0.2)
}

private func getFileSize() -> Int64 {
    let resources = PHAssetResource.assetResources(for: phAsset)
    guard let resource = resources.first,
          let size = resource.value(forKey: "fileSize") as? Int64 else {
        return 0
    }
    return size
}
```
  </action>
  <verify>Build the project with Cmd+B - should compile without errors. The qualityScore property should be accessible from PhotoAsset instances.</verify>
  <done>PhotoAsset has qualityScore computed property that returns a Double between 0 and 1 based on resolution, file size, and recency.</done>
</task>

<task type="auto">
  <name>Task 2: Add selection helpers to DuplicateGroup</name>
  <files>DuplicatePhotos/Models/DuplicateGroup.swift</files>
  <action>
Add computed properties to DuplicateGroup:

1. `bestPhoto: PhotoAsset?` - returns the photo with highest qualityScore
2. `photosToDelete: [PhotoAsset]` - returns all photos except the best one

Implementation:
```swift
/// The highest quality photo in the group (should be kept)
var bestPhoto: PhotoAsset? {
    photos.max(by: { $0.qualityScore < $1.qualityScore })
}

/// Photos that should be deleted (all except the best)
var photosToDelete: [PhotoAsset] {
    guard let best = bestPhoto else { return [] }
    return photos.filter { $0.id != best.id }
}

/// IDs of photos to delete (for Set operations in UI)
var photosToDeleteIds: Set<String> {
    Set(photosToDelete.map { $0.id })
}
```

These properties enable the UI to:
- Highlight the "best" photo
- Auto-select all other photos for deletion
- Allow user to override by deselecting
  </action>
  <verify>Build the project with Cmd+B - should compile without errors. Test in Preview or with print statement that bestPhoto returns a photo and photosToDelete returns count-1 photos.</verify>
  <done>DuplicateGroup has bestPhoto, photosToDelete, and photosToDeleteIds computed properties.</done>
</task>

<task type="auto">
  <name>Task 3: Add group removal to ScanViewModel</name>
  <files>DuplicatePhotos/ViewModels/ScanViewModel.swift</files>
  <action>
Add methods to ScanViewModel for managing groups after deletion:

1. `removeGroup(id: UUID)` - removes a group from duplicateGroups by ID
2. `removePhotosFromGroups(photoIds: Set<String>)` - removes specific photos and cleans up empty groups

Implementation:
```swift
/// Remove a group after all its duplicates are deleted
func removeGroup(id: UUID) {
    duplicateGroups.removeAll { $0.id == id }
}

/// Remove specific photos from groups (for partial deletion)
/// Cleans up groups that become empty or have only 1 photo
func removePhotosFromGroups(photoIds: Set<String>) {
    duplicateGroups = duplicateGroups.compactMap { group in
        let remainingPhotos = group.photos.filter { !photoIds.contains($0.id) }
        // Group needs at least 2 photos to be meaningful
        guard remainingPhotos.count >= 2 else { return nil }
        return DuplicateGroup(
            photos: remainingPhotos,
            similarityScores: group.similarityScores
        )
    }
}

/// Count of total duplicate photos that could be deleted
var totalPhotosToDelete: Int {
    duplicateGroups.reduce(0) { $0 + $1.photosToDelete.count }
}
```

These methods enable the UI to update state immediately after deletion without rescanning.
  </action>
  <verify>Build the project with Cmd+B - should compile without errors. The methods should be accessible from Views that have access to the viewModel.</verify>
  <done>ScanViewModel has removeGroup(), removePhotosFromGroups(), and totalPhotosToDelete for managing groups after deletion.</done>
</task>

</tasks>

<verification>
All verification is build-based for this plan:
1. `Cmd+B` in Xcode builds successfully
2. PhotoAsset.qualityScore is accessible
3. DuplicateGroup.bestPhoto and photosToDelete work
4. ScanViewModel.removeGroup() is available
</verification>

<success_criteria>
- [ ] PhotoAsset has qualityScore computed property
- [ ] DuplicateGroup has bestPhoto, photosToDelete, photosToDeleteIds properties
- [ ] ScanViewModel has removeGroup(), removePhotosFromGroups(), totalPhotosToDelete
- [ ] Project builds without errors
</success_criteria>

<output>
After completion, create `.planning/phases/72-batch-operations/72-01-SUMMARY.md`
</output>
